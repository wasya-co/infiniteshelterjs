"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "ishlibjs_node_modules_ionic_core_components_input-shims_js";
exports.ids = ["ishlibjs_node_modules_ionic_core_components_input-shims_js"];
exports.modules = {

/***/ "../ishlibjs/node_modules/@ionic/core/components/input-shims.js":
/*!**********************************************************************!*\
  !*** ../ishlibjs/node_modules/@ionic/core/components/input-shims.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"startInputShims\": () => (/* binding */ startInputShims)\n/* harmony export */ });\n/* harmony import */ var _helpers_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./helpers.js */ \"../ishlibjs/node_modules/@ionic/core/components/helpers.js\");\n/*!\n * (C) Ionic http://ionicframework.com - MIT License\n */\n\n\nconst cloneMap = new WeakMap();\nconst relocateInput = (componentEl, inputEl, shouldRelocate, inputRelativeY = 0) => {\n  if (cloneMap.has(componentEl) === shouldRelocate) {\n    return;\n  }\n  if (shouldRelocate) {\n    addClone(componentEl, inputEl, inputRelativeY);\n  }\n  else {\n    removeClone(componentEl, inputEl);\n  }\n};\nconst isFocused = (input) => {\n  return input === input.getRootNode().activeElement;\n};\nconst addClone = (componentEl, inputEl, inputRelativeY) => {\n  // this allows for the actual input to receive the focus from\n  // the user's touch event, but before it receives focus, it\n  // moves the actual input to a location that will not screw\n  // up the app's layout, and does not allow the native browser\n  // to attempt to scroll the input into place (messing up headers/footers)\n  // the cloned input fills the area of where native input should be\n  // while the native input fakes out the browser by relocating itself\n  // before it receives the actual focus event\n  // We hide the focused input (with the visible caret) invisible by making it scale(0),\n  const parentEl = inputEl.parentNode;\n  // DOM WRITES\n  const clonedEl = inputEl.cloneNode(false);\n  clonedEl.classList.add('cloned-input');\n  clonedEl.tabIndex = -1;\n  parentEl.appendChild(clonedEl);\n  cloneMap.set(componentEl, clonedEl);\n  const doc = componentEl.ownerDocument;\n  const tx = doc.dir === 'rtl' ? 9999 : -9999;\n  componentEl.style.pointerEvents = 'none';\n  inputEl.style.transform = `translate3d(${tx}px,${inputRelativeY}px,0) scale(0)`;\n};\nconst removeClone = (componentEl, inputEl) => {\n  const clone = cloneMap.get(componentEl);\n  if (clone) {\n    cloneMap.delete(componentEl);\n    clone.remove();\n  }\n  componentEl.style.pointerEvents = '';\n  inputEl.style.transform = '';\n};\n\nconst enableHideCaretOnScroll = (componentEl, inputEl, scrollEl) => {\n  if (!scrollEl || !inputEl) {\n    return () => { return; };\n  }\n  const scrollHideCaret = (shouldHideCaret) => {\n    if (isFocused(inputEl)) {\n      relocateInput(componentEl, inputEl, shouldHideCaret);\n    }\n  };\n  const onBlur = () => relocateInput(componentEl, inputEl, false);\n  const hideCaret = () => scrollHideCaret(true);\n  const showCaret = () => scrollHideCaret(false);\n  (0,_helpers_js__WEBPACK_IMPORTED_MODULE_0__.a)(scrollEl, 'ionScrollStart', hideCaret);\n  (0,_helpers_js__WEBPACK_IMPORTED_MODULE_0__.a)(scrollEl, 'ionScrollEnd', showCaret);\n  inputEl.addEventListener('blur', onBlur);\n  return () => {\n    (0,_helpers_js__WEBPACK_IMPORTED_MODULE_0__.b)(scrollEl, 'ionScrollStart', hideCaret);\n    (0,_helpers_js__WEBPACK_IMPORTED_MODULE_0__.b)(scrollEl, 'ionScrollEnd', showCaret);\n    inputEl.addEventListener('ionBlur', onBlur);\n  };\n};\n\nconst SKIP_SELECTOR = 'input, textarea, [no-blur], [contenteditable]';\nconst enableInputBlurring = () => {\n  let focused = true;\n  let didScroll = false;\n  const doc = document;\n  const onScroll = () => {\n    didScroll = true;\n  };\n  const onFocusin = () => {\n    focused = true;\n  };\n  const onTouchend = (ev) => {\n    // if app did scroll return early\n    if (didScroll) {\n      didScroll = false;\n      return;\n    }\n    const active = doc.activeElement;\n    if (!active) {\n      return;\n    }\n    // only blur if the active element is a text-input or a textarea\n    if (active.matches(SKIP_SELECTOR)) {\n      return;\n    }\n    // if the selected target is the active element, do not blur\n    const tapped = ev.target;\n    if (tapped === active) {\n      return;\n    }\n    if (tapped.matches(SKIP_SELECTOR) || tapped.closest(SKIP_SELECTOR)) {\n      return;\n    }\n    focused = false;\n    // TODO: find a better way, why 50ms?\n    setTimeout(() => {\n      if (!focused) {\n        active.blur();\n      }\n    }, 50);\n  };\n  (0,_helpers_js__WEBPACK_IMPORTED_MODULE_0__.a)(doc, 'ionScrollStart', onScroll);\n  doc.addEventListener('focusin', onFocusin, true);\n  doc.addEventListener('touchend', onTouchend, false);\n  return () => {\n    (0,_helpers_js__WEBPACK_IMPORTED_MODULE_0__.b)(doc, 'ionScrollStart', onScroll, true);\n    doc.removeEventListener('focusin', onFocusin, true);\n    doc.removeEventListener('touchend', onTouchend, false);\n  };\n};\n\nconst SCROLL_ASSIST_SPEED = 0.3;\nconst getScrollData = (componentEl, contentEl, keyboardHeight) => {\n  const itemEl = componentEl.closest('ion-item,[ion-item]') || componentEl;\n  return calcScrollData(itemEl.getBoundingClientRect(), contentEl.getBoundingClientRect(), keyboardHeight, componentEl.ownerDocument.defaultView.innerHeight);\n};\nconst calcScrollData = (inputRect, contentRect, keyboardHeight, platformHeight) => {\n  // compute input's Y values relative to the body\n  const inputTop = inputRect.top;\n  const inputBottom = inputRect.bottom;\n  // compute visible area\n  const visibleAreaTop = contentRect.top;\n  const visibleAreaBottom = Math.min(contentRect.bottom, platformHeight - keyboardHeight);\n  // compute safe area\n  const safeAreaTop = visibleAreaTop + 15;\n  const safeAreaBottom = visibleAreaBottom * 0.75;\n  // figure out if each edge of the input is within the safe area\n  const distanceToBottom = safeAreaBottom - inputBottom;\n  const distanceToTop = safeAreaTop - inputTop;\n  // desiredScrollAmount is the negated distance to the safe area according to our calculations.\n  const desiredScrollAmount = Math.round((distanceToBottom < 0)\n    ? -distanceToBottom\n    : (distanceToTop > 0)\n      ? -distanceToTop\n      : 0);\n  // our calculations make some assumptions that aren't always true, like the keyboard being closed when an input\n  // gets focus, so make sure we don't scroll the input above the visible area\n  const scrollAmount = Math.min(desiredScrollAmount, inputTop - visibleAreaTop);\n  const distance = Math.abs(scrollAmount);\n  const duration = distance / SCROLL_ASSIST_SPEED;\n  const scrollDuration = Math.min(400, Math.max(150, duration));\n  return {\n    scrollAmount,\n    scrollDuration,\n    scrollPadding: keyboardHeight,\n    inputSafeY: -(inputTop - safeAreaTop) + 4\n  };\n};\n\nconst enableScrollAssist = (componentEl, inputEl, contentEl, footerEl, keyboardHeight) => {\n  let coord;\n  const touchStart = (ev) => {\n    coord = (0,_helpers_js__WEBPACK_IMPORTED_MODULE_0__.p)(ev);\n  };\n  const touchEnd = (ev) => {\n    // input cover touchend/mouseup\n    if (!coord) {\n      return;\n    }\n    // get where the touchend/mouseup ended\n    const endCoord = (0,_helpers_js__WEBPACK_IMPORTED_MODULE_0__.p)(ev);\n    // focus this input if the pointer hasn't moved XX pixels\n    // and the input doesn't already have focus\n    if (!hasPointerMoved(6, coord, endCoord) && !isFocused(inputEl)) {\n      ev.stopPropagation();\n      // begin the input focus process\n      jsSetFocus(componentEl, inputEl, contentEl, footerEl, keyboardHeight);\n    }\n  };\n  componentEl.addEventListener('touchstart', touchStart, true);\n  componentEl.addEventListener('touchend', touchEnd, true);\n  return () => {\n    componentEl.removeEventListener('touchstart', touchStart, true);\n    componentEl.removeEventListener('touchend', touchEnd, true);\n  };\n};\nconst jsSetFocus = async (componentEl, inputEl, contentEl, footerEl, keyboardHeight) => {\n  if (!contentEl && !footerEl) {\n    return;\n  }\n  const scrollData = getScrollData(componentEl, (contentEl || footerEl), keyboardHeight);\n  if (contentEl && Math.abs(scrollData.scrollAmount) < 4) {\n    // the text input is in a safe position that doesn't\n    // require it to be scrolled into view, just set focus now\n    inputEl.focus();\n    return;\n  }\n  // temporarily move the focus to the focus holder so the browser\n  // doesn't freak out while it's trying to get the input in place\n  // at this point the native text input still does not have focus\n  relocateInput(componentEl, inputEl, true, scrollData.inputSafeY);\n  inputEl.focus();\n  /**\n   * Relocating/Focusing input causes the\n   * click event to be cancelled, so\n   * manually fire one here.\n   */\n  (0,_helpers_js__WEBPACK_IMPORTED_MODULE_0__.r)(() => componentEl.click());\n  /* tslint:disable-next-line */\n  if (typeof window !== 'undefined') {\n    let scrollContentTimeout;\n    const scrollContent = async () => {\n      // clean up listeners and timeouts\n      if (scrollContentTimeout !== undefined) {\n        clearTimeout(scrollContentTimeout);\n      }\n      window.removeEventListener('ionKeyboardDidShow', doubleKeyboardEventListener);\n      window.removeEventListener('ionKeyboardDidShow', scrollContent);\n      // scroll the input into place\n      if (contentEl) {\n        await contentEl.scrollByPoint(0, scrollData.scrollAmount, scrollData.scrollDuration);\n      }\n      // the scroll view is in the correct position now\n      // give the native text input focus\n      relocateInput(componentEl, inputEl, false, scrollData.inputSafeY);\n      // ensure this is the focused input\n      inputEl.focus();\n    };\n    const doubleKeyboardEventListener = () => {\n      window.removeEventListener('ionKeyboardDidShow', doubleKeyboardEventListener);\n      window.addEventListener('ionKeyboardDidShow', scrollContent);\n    };\n    if (contentEl) {\n      const scrollEl = await contentEl.getScrollElement();\n      /**\n       * scrollData will only consider the amount we need\n       * to scroll in order to properly bring the input\n       * into view. It will not consider the amount\n       * we can scroll in the content element.\n       * As a result, scrollData may request a greater\n       * scroll position than is currently available\n       * in the DOM. If this is the case, we need to\n       * wait for the webview to resize/the keyboard\n       * to show in order for additional scroll\n       * bandwidth to become available.\n       */\n      const totalScrollAmount = scrollEl.scrollHeight - scrollEl.clientHeight;\n      if (scrollData.scrollAmount > (totalScrollAmount - scrollEl.scrollTop)) {\n        /**\n         * On iOS devices, the system will show a \"Passwords\" bar above the keyboard\n         * after the initial keyboard is shown. This prevents the webview from resizing\n         * until the \"Passwords\" bar is shown, so we need to wait for that to happen first.\n         */\n        if (inputEl.type === 'password') {\n          // Add 50px to account for the \"Passwords\" bar\n          scrollData.scrollAmount += 50;\n          window.addEventListener('ionKeyboardDidShow', doubleKeyboardEventListener);\n        }\n        else {\n          window.addEventListener('ionKeyboardDidShow', scrollContent);\n        }\n        /**\n         * This should only fire in 2 instances:\n         * 1. The app is very slow.\n         * 2. The app is running in a browser on an old OS\n         * that does not support Ionic Keyboard Events\n         */\n        scrollContentTimeout = setTimeout(scrollContent, 1000);\n        return;\n      }\n    }\n    scrollContent();\n  }\n};\nconst hasPointerMoved = (threshold, startCoord, endCoord) => {\n  if (startCoord && endCoord) {\n    const deltaX = (startCoord.x - endCoord.x);\n    const deltaY = (startCoord.y - endCoord.y);\n    const distance = deltaX * deltaX + deltaY * deltaY;\n    return distance > (threshold * threshold);\n  }\n  return false;\n};\n\nconst PADDING_TIMER_KEY = '$ionPaddingTimer';\nconst enableScrollPadding = (keyboardHeight) => {\n  const doc = document;\n  const onFocusin = (ev) => {\n    setScrollPadding(ev.target, keyboardHeight);\n  };\n  const onFocusout = (ev) => {\n    setScrollPadding(ev.target, 0);\n  };\n  doc.addEventListener('focusin', onFocusin);\n  doc.addEventListener('focusout', onFocusout);\n  return () => {\n    doc.removeEventListener('focusin', onFocusin);\n    doc.removeEventListener('focusout', onFocusout);\n  };\n};\nconst setScrollPadding = (input, keyboardHeight) => {\n  if (input.tagName !== 'INPUT') {\n    return;\n  }\n  if (input.parentElement && input.parentElement.tagName === 'ION-INPUT') {\n    return;\n  }\n  if (input.parentElement &&\n    input.parentElement.parentElement &&\n    input.parentElement.parentElement.tagName === 'ION-SEARCHBAR') {\n    return;\n  }\n  const el = input.closest('ion-content');\n  if (el === null) {\n    return;\n  }\n  const timer = el[PADDING_TIMER_KEY];\n  if (timer) {\n    clearTimeout(timer);\n  }\n  if (keyboardHeight > 0) {\n    el.style.setProperty('--keyboard-offset', `${keyboardHeight}px`);\n  }\n  else {\n    el[PADDING_TIMER_KEY] = setTimeout(() => {\n      el.style.setProperty('--keyboard-offset', '0px');\n    }, 120);\n  }\n};\n\nconst INPUT_BLURRING = true;\nconst SCROLL_PADDING = true;\nconst startInputShims = (config) => {\n  const doc = document;\n  const keyboardHeight = config.getNumber('keyboardHeight', 290);\n  const scrollAssist = config.getBoolean('scrollAssist', true);\n  const hideCaret = config.getBoolean('hideCaretOnScroll', true);\n  const inputBlurring = config.getBoolean('inputBlurring', true);\n  const scrollPadding = config.getBoolean('scrollPadding', true);\n  const inputs = Array.from(doc.querySelectorAll('ion-input, ion-textarea'));\n  const hideCaretMap = new WeakMap();\n  const scrollAssistMap = new WeakMap();\n  const registerInput = async (componentEl) => {\n    await new Promise(resolve => (0,_helpers_js__WEBPACK_IMPORTED_MODULE_0__.c)(componentEl, resolve));\n    const inputRoot = componentEl.shadowRoot || componentEl;\n    const inputEl = inputRoot.querySelector('input') || inputRoot.querySelector('textarea');\n    const scrollEl = componentEl.closest('ion-content');\n    const footerEl = (!scrollEl) ? componentEl.closest('ion-footer') : null;\n    if (!inputEl) {\n      return;\n    }\n    if (!!scrollEl && hideCaret && !hideCaretMap.has(componentEl)) {\n      const rmFn = enableHideCaretOnScroll(componentEl, inputEl, scrollEl);\n      hideCaretMap.set(componentEl, rmFn);\n    }\n    if ((!!scrollEl || !!footerEl) && scrollAssist && !scrollAssistMap.has(componentEl)) {\n      const rmFn = enableScrollAssist(componentEl, inputEl, scrollEl, footerEl, keyboardHeight);\n      scrollAssistMap.set(componentEl, rmFn);\n    }\n  };\n  const unregisterInput = (componentEl) => {\n    if (hideCaret) {\n      const fn = hideCaretMap.get(componentEl);\n      if (fn) {\n        fn();\n      }\n      hideCaretMap.delete(componentEl);\n    }\n    if (scrollAssist) {\n      const fn = scrollAssistMap.get(componentEl);\n      if (fn) {\n        fn();\n      }\n      scrollAssistMap.delete(componentEl);\n    }\n  };\n  if (inputBlurring && INPUT_BLURRING) {\n    enableInputBlurring();\n  }\n  if (scrollPadding && SCROLL_PADDING) {\n    enableScrollPadding(keyboardHeight);\n  }\n  // Input might be already loaded in the DOM before ion-device-hacks did.\n  // At this point we need to look for all of the inputs not registered yet\n  // and register them.\n  for (const input of inputs) {\n    registerInput(input);\n  }\n  doc.addEventListener('ionInputDidLoad', ((ev) => {\n    registerInput(ev.detail);\n  }));\n  doc.addEventListener('ionInputDidUnload', ((ev) => {\n    unregisterInput(ev.detail);\n  }));\n};\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vaXNobGlianMvbm9kZV9tb2R1bGVzL0Bpb25pYy9jb3JlL2NvbXBvbmVudHMvaW5wdXQtc2hpbXMuanMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDbUk7O0FBRW5JO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkMsR0FBRyxLQUFLLGVBQWU7QUFDbEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFLDhDQUFnQjtBQUNsQixFQUFFLDhDQUFnQjtBQUNsQjtBQUNBO0FBQ0EsSUFBSSw4Q0FBbUI7QUFDdkIsSUFBSSw4Q0FBbUI7QUFDdkI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEVBQUUsOENBQWdCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBLElBQUksOENBQW1CO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVksOENBQVk7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsOENBQVk7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRSw4Q0FBRztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRCxlQUFlO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsOENBQWdCO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRTJCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vSW5maW5pdGVTaGVsdGVyLy4uL2lzaGxpYmpzL25vZGVfbW9kdWxlcy9AaW9uaWMvY29yZS9jb21wb25lbnRzL2lucHV0LXNoaW1zLmpzPzQzNDEiXSwic291cmNlc0NvbnRlbnQiOlsiLyohXG4gKiAoQykgSW9uaWMgaHR0cDovL2lvbmljZnJhbWV3b3JrLmNvbSAtIE1JVCBMaWNlbnNlXG4gKi9cbmltcG9ydCB7IGEgYXMgYWRkRXZlbnRMaXN0ZW5lciwgYiBhcyByZW1vdmVFdmVudExpc3RlbmVyLCByIGFzIHJhZiwgcCBhcyBwb2ludGVyQ29vcmQsIGMgYXMgY29tcG9uZW50T25SZWFkeSB9IGZyb20gJy4vaGVscGVycy5qcyc7XG5cbmNvbnN0IGNsb25lTWFwID0gbmV3IFdlYWtNYXAoKTtcbmNvbnN0IHJlbG9jYXRlSW5wdXQgPSAoY29tcG9uZW50RWwsIGlucHV0RWwsIHNob3VsZFJlbG9jYXRlLCBpbnB1dFJlbGF0aXZlWSA9IDApID0+IHtcbiAgaWYgKGNsb25lTWFwLmhhcyhjb21wb25lbnRFbCkgPT09IHNob3VsZFJlbG9jYXRlKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGlmIChzaG91bGRSZWxvY2F0ZSkge1xuICAgIGFkZENsb25lKGNvbXBvbmVudEVsLCBpbnB1dEVsLCBpbnB1dFJlbGF0aXZlWSk7XG4gIH1cbiAgZWxzZSB7XG4gICAgcmVtb3ZlQ2xvbmUoY29tcG9uZW50RWwsIGlucHV0RWwpO1xuICB9XG59O1xuY29uc3QgaXNGb2N1c2VkID0gKGlucHV0KSA9PiB7XG4gIHJldHVybiBpbnB1dCA9PT0gaW5wdXQuZ2V0Um9vdE5vZGUoKS5hY3RpdmVFbGVtZW50O1xufTtcbmNvbnN0IGFkZENsb25lID0gKGNvbXBvbmVudEVsLCBpbnB1dEVsLCBpbnB1dFJlbGF0aXZlWSkgPT4ge1xuICAvLyB0aGlzIGFsbG93cyBmb3IgdGhlIGFjdHVhbCBpbnB1dCB0byByZWNlaXZlIHRoZSBmb2N1cyBmcm9tXG4gIC8vIHRoZSB1c2VyJ3MgdG91Y2ggZXZlbnQsIGJ1dCBiZWZvcmUgaXQgcmVjZWl2ZXMgZm9jdXMsIGl0XG4gIC8vIG1vdmVzIHRoZSBhY3R1YWwgaW5wdXQgdG8gYSBsb2NhdGlvbiB0aGF0IHdpbGwgbm90IHNjcmV3XG4gIC8vIHVwIHRoZSBhcHAncyBsYXlvdXQsIGFuZCBkb2VzIG5vdCBhbGxvdyB0aGUgbmF0aXZlIGJyb3dzZXJcbiAgLy8gdG8gYXR0ZW1wdCB0byBzY3JvbGwgdGhlIGlucHV0IGludG8gcGxhY2UgKG1lc3NpbmcgdXAgaGVhZGVycy9mb290ZXJzKVxuICAvLyB0aGUgY2xvbmVkIGlucHV0IGZpbGxzIHRoZSBhcmVhIG9mIHdoZXJlIG5hdGl2ZSBpbnB1dCBzaG91bGQgYmVcbiAgLy8gd2hpbGUgdGhlIG5hdGl2ZSBpbnB1dCBmYWtlcyBvdXQgdGhlIGJyb3dzZXIgYnkgcmVsb2NhdGluZyBpdHNlbGZcbiAgLy8gYmVmb3JlIGl0IHJlY2VpdmVzIHRoZSBhY3R1YWwgZm9jdXMgZXZlbnRcbiAgLy8gV2UgaGlkZSB0aGUgZm9jdXNlZCBpbnB1dCAod2l0aCB0aGUgdmlzaWJsZSBjYXJldCkgaW52aXNpYmxlIGJ5IG1ha2luZyBpdCBzY2FsZSgwKSxcbiAgY29uc3QgcGFyZW50RWwgPSBpbnB1dEVsLnBhcmVudE5vZGU7XG4gIC8vIERPTSBXUklURVNcbiAgY29uc3QgY2xvbmVkRWwgPSBpbnB1dEVsLmNsb25lTm9kZShmYWxzZSk7XG4gIGNsb25lZEVsLmNsYXNzTGlzdC5hZGQoJ2Nsb25lZC1pbnB1dCcpO1xuICBjbG9uZWRFbC50YWJJbmRleCA9IC0xO1xuICBwYXJlbnRFbC5hcHBlbmRDaGlsZChjbG9uZWRFbCk7XG4gIGNsb25lTWFwLnNldChjb21wb25lbnRFbCwgY2xvbmVkRWwpO1xuICBjb25zdCBkb2MgPSBjb21wb25lbnRFbC5vd25lckRvY3VtZW50O1xuICBjb25zdCB0eCA9IGRvYy5kaXIgPT09ICdydGwnID8gOTk5OSA6IC05OTk5O1xuICBjb21wb25lbnRFbC5zdHlsZS5wb2ludGVyRXZlbnRzID0gJ25vbmUnO1xuICBpbnB1dEVsLnN0eWxlLnRyYW5zZm9ybSA9IGB0cmFuc2xhdGUzZCgke3R4fXB4LCR7aW5wdXRSZWxhdGl2ZVl9cHgsMCkgc2NhbGUoMClgO1xufTtcbmNvbnN0IHJlbW92ZUNsb25lID0gKGNvbXBvbmVudEVsLCBpbnB1dEVsKSA9PiB7XG4gIGNvbnN0IGNsb25lID0gY2xvbmVNYXAuZ2V0KGNvbXBvbmVudEVsKTtcbiAgaWYgKGNsb25lKSB7XG4gICAgY2xvbmVNYXAuZGVsZXRlKGNvbXBvbmVudEVsKTtcbiAgICBjbG9uZS5yZW1vdmUoKTtcbiAgfVxuICBjb21wb25lbnRFbC5zdHlsZS5wb2ludGVyRXZlbnRzID0gJyc7XG4gIGlucHV0RWwuc3R5bGUudHJhbnNmb3JtID0gJyc7XG59O1xuXG5jb25zdCBlbmFibGVIaWRlQ2FyZXRPblNjcm9sbCA9IChjb21wb25lbnRFbCwgaW5wdXRFbCwgc2Nyb2xsRWwpID0+IHtcbiAgaWYgKCFzY3JvbGxFbCB8fCAhaW5wdXRFbCkge1xuICAgIHJldHVybiAoKSA9PiB7IHJldHVybjsgfTtcbiAgfVxuICBjb25zdCBzY3JvbGxIaWRlQ2FyZXQgPSAoc2hvdWxkSGlkZUNhcmV0KSA9PiB7XG4gICAgaWYgKGlzRm9jdXNlZChpbnB1dEVsKSkge1xuICAgICAgcmVsb2NhdGVJbnB1dChjb21wb25lbnRFbCwgaW5wdXRFbCwgc2hvdWxkSGlkZUNhcmV0KTtcbiAgICB9XG4gIH07XG4gIGNvbnN0IG9uQmx1ciA9ICgpID0+IHJlbG9jYXRlSW5wdXQoY29tcG9uZW50RWwsIGlucHV0RWwsIGZhbHNlKTtcbiAgY29uc3QgaGlkZUNhcmV0ID0gKCkgPT4gc2Nyb2xsSGlkZUNhcmV0KHRydWUpO1xuICBjb25zdCBzaG93Q2FyZXQgPSAoKSA9PiBzY3JvbGxIaWRlQ2FyZXQoZmFsc2UpO1xuICBhZGRFdmVudExpc3RlbmVyKHNjcm9sbEVsLCAnaW9uU2Nyb2xsU3RhcnQnLCBoaWRlQ2FyZXQpO1xuICBhZGRFdmVudExpc3RlbmVyKHNjcm9sbEVsLCAnaW9uU2Nyb2xsRW5kJywgc2hvd0NhcmV0KTtcbiAgaW5wdXRFbC5hZGRFdmVudExpc3RlbmVyKCdibHVyJywgb25CbHVyKTtcbiAgcmV0dXJuICgpID0+IHtcbiAgICByZW1vdmVFdmVudExpc3RlbmVyKHNjcm9sbEVsLCAnaW9uU2Nyb2xsU3RhcnQnLCBoaWRlQ2FyZXQpO1xuICAgIHJlbW92ZUV2ZW50TGlzdGVuZXIoc2Nyb2xsRWwsICdpb25TY3JvbGxFbmQnLCBzaG93Q2FyZXQpO1xuICAgIGlucHV0RWwuYWRkRXZlbnRMaXN0ZW5lcignaW9uQmx1cicsIG9uQmx1cik7XG4gIH07XG59O1xuXG5jb25zdCBTS0lQX1NFTEVDVE9SID0gJ2lucHV0LCB0ZXh0YXJlYSwgW25vLWJsdXJdLCBbY29udGVudGVkaXRhYmxlXSc7XG5jb25zdCBlbmFibGVJbnB1dEJsdXJyaW5nID0gKCkgPT4ge1xuICBsZXQgZm9jdXNlZCA9IHRydWU7XG4gIGxldCBkaWRTY3JvbGwgPSBmYWxzZTtcbiAgY29uc3QgZG9jID0gZG9jdW1lbnQ7XG4gIGNvbnN0IG9uU2Nyb2xsID0gKCkgPT4ge1xuICAgIGRpZFNjcm9sbCA9IHRydWU7XG4gIH07XG4gIGNvbnN0IG9uRm9jdXNpbiA9ICgpID0+IHtcbiAgICBmb2N1c2VkID0gdHJ1ZTtcbiAgfTtcbiAgY29uc3Qgb25Ub3VjaGVuZCA9IChldikgPT4ge1xuICAgIC8vIGlmIGFwcCBkaWQgc2Nyb2xsIHJldHVybiBlYXJseVxuICAgIGlmIChkaWRTY3JvbGwpIHtcbiAgICAgIGRpZFNjcm9sbCA9IGZhbHNlO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBhY3RpdmUgPSBkb2MuYWN0aXZlRWxlbWVudDtcbiAgICBpZiAoIWFjdGl2ZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICAvLyBvbmx5IGJsdXIgaWYgdGhlIGFjdGl2ZSBlbGVtZW50IGlzIGEgdGV4dC1pbnB1dCBvciBhIHRleHRhcmVhXG4gICAgaWYgKGFjdGl2ZS5tYXRjaGVzKFNLSVBfU0VMRUNUT1IpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIC8vIGlmIHRoZSBzZWxlY3RlZCB0YXJnZXQgaXMgdGhlIGFjdGl2ZSBlbGVtZW50LCBkbyBub3QgYmx1clxuICAgIGNvbnN0IHRhcHBlZCA9IGV2LnRhcmdldDtcbiAgICBpZiAodGFwcGVkID09PSBhY3RpdmUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHRhcHBlZC5tYXRjaGVzKFNLSVBfU0VMRUNUT1IpIHx8IHRhcHBlZC5jbG9zZXN0KFNLSVBfU0VMRUNUT1IpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGZvY3VzZWQgPSBmYWxzZTtcbiAgICAvLyBUT0RPOiBmaW5kIGEgYmV0dGVyIHdheSwgd2h5IDUwbXM/XG4gICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICBpZiAoIWZvY3VzZWQpIHtcbiAgICAgICAgYWN0aXZlLmJsdXIoKTtcbiAgICAgIH1cbiAgICB9LCA1MCk7XG4gIH07XG4gIGFkZEV2ZW50TGlzdGVuZXIoZG9jLCAnaW9uU2Nyb2xsU3RhcnQnLCBvblNjcm9sbCk7XG4gIGRvYy5hZGRFdmVudExpc3RlbmVyKCdmb2N1c2luJywgb25Gb2N1c2luLCB0cnVlKTtcbiAgZG9jLmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNoZW5kJywgb25Ub3VjaGVuZCwgZmFsc2UpO1xuICByZXR1cm4gKCkgPT4ge1xuICAgIHJlbW92ZUV2ZW50TGlzdGVuZXIoZG9jLCAnaW9uU2Nyb2xsU3RhcnQnLCBvblNjcm9sbCwgdHJ1ZSk7XG4gICAgZG9jLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2ZvY3VzaW4nLCBvbkZvY3VzaW4sIHRydWUpO1xuICAgIGRvYy5yZW1vdmVFdmVudExpc3RlbmVyKCd0b3VjaGVuZCcsIG9uVG91Y2hlbmQsIGZhbHNlKTtcbiAgfTtcbn07XG5cbmNvbnN0IFNDUk9MTF9BU1NJU1RfU1BFRUQgPSAwLjM7XG5jb25zdCBnZXRTY3JvbGxEYXRhID0gKGNvbXBvbmVudEVsLCBjb250ZW50RWwsIGtleWJvYXJkSGVpZ2h0KSA9PiB7XG4gIGNvbnN0IGl0ZW1FbCA9IGNvbXBvbmVudEVsLmNsb3Nlc3QoJ2lvbi1pdGVtLFtpb24taXRlbV0nKSB8fCBjb21wb25lbnRFbDtcbiAgcmV0dXJuIGNhbGNTY3JvbGxEYXRhKGl0ZW1FbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSwgY29udGVudEVsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLCBrZXlib2FyZEhlaWdodCwgY29tcG9uZW50RWwub3duZXJEb2N1bWVudC5kZWZhdWx0Vmlldy5pbm5lckhlaWdodCk7XG59O1xuY29uc3QgY2FsY1Njcm9sbERhdGEgPSAoaW5wdXRSZWN0LCBjb250ZW50UmVjdCwga2V5Ym9hcmRIZWlnaHQsIHBsYXRmb3JtSGVpZ2h0KSA9PiB7XG4gIC8vIGNvbXB1dGUgaW5wdXQncyBZIHZhbHVlcyByZWxhdGl2ZSB0byB0aGUgYm9keVxuICBjb25zdCBpbnB1dFRvcCA9IGlucHV0UmVjdC50b3A7XG4gIGNvbnN0IGlucHV0Qm90dG9tID0gaW5wdXRSZWN0LmJvdHRvbTtcbiAgLy8gY29tcHV0ZSB2aXNpYmxlIGFyZWFcbiAgY29uc3QgdmlzaWJsZUFyZWFUb3AgPSBjb250ZW50UmVjdC50b3A7XG4gIGNvbnN0IHZpc2libGVBcmVhQm90dG9tID0gTWF0aC5taW4oY29udGVudFJlY3QuYm90dG9tLCBwbGF0Zm9ybUhlaWdodCAtIGtleWJvYXJkSGVpZ2h0KTtcbiAgLy8gY29tcHV0ZSBzYWZlIGFyZWFcbiAgY29uc3Qgc2FmZUFyZWFUb3AgPSB2aXNpYmxlQXJlYVRvcCArIDE1O1xuICBjb25zdCBzYWZlQXJlYUJvdHRvbSA9IHZpc2libGVBcmVhQm90dG9tICogMC43NTtcbiAgLy8gZmlndXJlIG91dCBpZiBlYWNoIGVkZ2Ugb2YgdGhlIGlucHV0IGlzIHdpdGhpbiB0aGUgc2FmZSBhcmVhXG4gIGNvbnN0IGRpc3RhbmNlVG9Cb3R0b20gPSBzYWZlQXJlYUJvdHRvbSAtIGlucHV0Qm90dG9tO1xuICBjb25zdCBkaXN0YW5jZVRvVG9wID0gc2FmZUFyZWFUb3AgLSBpbnB1dFRvcDtcbiAgLy8gZGVzaXJlZFNjcm9sbEFtb3VudCBpcyB0aGUgbmVnYXRlZCBkaXN0YW5jZSB0byB0aGUgc2FmZSBhcmVhIGFjY29yZGluZyB0byBvdXIgY2FsY3VsYXRpb25zLlxuICBjb25zdCBkZXNpcmVkU2Nyb2xsQW1vdW50ID0gTWF0aC5yb3VuZCgoZGlzdGFuY2VUb0JvdHRvbSA8IDApXG4gICAgPyAtZGlzdGFuY2VUb0JvdHRvbVxuICAgIDogKGRpc3RhbmNlVG9Ub3AgPiAwKVxuICAgICAgPyAtZGlzdGFuY2VUb1RvcFxuICAgICAgOiAwKTtcbiAgLy8gb3VyIGNhbGN1bGF0aW9ucyBtYWtlIHNvbWUgYXNzdW1wdGlvbnMgdGhhdCBhcmVuJ3QgYWx3YXlzIHRydWUsIGxpa2UgdGhlIGtleWJvYXJkIGJlaW5nIGNsb3NlZCB3aGVuIGFuIGlucHV0XG4gIC8vIGdldHMgZm9jdXMsIHNvIG1ha2Ugc3VyZSB3ZSBkb24ndCBzY3JvbGwgdGhlIGlucHV0IGFib3ZlIHRoZSB2aXNpYmxlIGFyZWFcbiAgY29uc3Qgc2Nyb2xsQW1vdW50ID0gTWF0aC5taW4oZGVzaXJlZFNjcm9sbEFtb3VudCwgaW5wdXRUb3AgLSB2aXNpYmxlQXJlYVRvcCk7XG4gIGNvbnN0IGRpc3RhbmNlID0gTWF0aC5hYnMoc2Nyb2xsQW1vdW50KTtcbiAgY29uc3QgZHVyYXRpb24gPSBkaXN0YW5jZSAvIFNDUk9MTF9BU1NJU1RfU1BFRUQ7XG4gIGNvbnN0IHNjcm9sbER1cmF0aW9uID0gTWF0aC5taW4oNDAwLCBNYXRoLm1heCgxNTAsIGR1cmF0aW9uKSk7XG4gIHJldHVybiB7XG4gICAgc2Nyb2xsQW1vdW50LFxuICAgIHNjcm9sbER1cmF0aW9uLFxuICAgIHNjcm9sbFBhZGRpbmc6IGtleWJvYXJkSGVpZ2h0LFxuICAgIGlucHV0U2FmZVk6IC0oaW5wdXRUb3AgLSBzYWZlQXJlYVRvcCkgKyA0XG4gIH07XG59O1xuXG5jb25zdCBlbmFibGVTY3JvbGxBc3Npc3QgPSAoY29tcG9uZW50RWwsIGlucHV0RWwsIGNvbnRlbnRFbCwgZm9vdGVyRWwsIGtleWJvYXJkSGVpZ2h0KSA9PiB7XG4gIGxldCBjb29yZDtcbiAgY29uc3QgdG91Y2hTdGFydCA9IChldikgPT4ge1xuICAgIGNvb3JkID0gcG9pbnRlckNvb3JkKGV2KTtcbiAgfTtcbiAgY29uc3QgdG91Y2hFbmQgPSAoZXYpID0+IHtcbiAgICAvLyBpbnB1dCBjb3ZlciB0b3VjaGVuZC9tb3VzZXVwXG4gICAgaWYgKCFjb29yZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICAvLyBnZXQgd2hlcmUgdGhlIHRvdWNoZW5kL21vdXNldXAgZW5kZWRcbiAgICBjb25zdCBlbmRDb29yZCA9IHBvaW50ZXJDb29yZChldik7XG4gICAgLy8gZm9jdXMgdGhpcyBpbnB1dCBpZiB0aGUgcG9pbnRlciBoYXNuJ3QgbW92ZWQgWFggcGl4ZWxzXG4gICAgLy8gYW5kIHRoZSBpbnB1dCBkb2Vzbid0IGFscmVhZHkgaGF2ZSBmb2N1c1xuICAgIGlmICghaGFzUG9pbnRlck1vdmVkKDYsIGNvb3JkLCBlbmRDb29yZCkgJiYgIWlzRm9jdXNlZChpbnB1dEVsKSkge1xuICAgICAgZXYuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAvLyBiZWdpbiB0aGUgaW5wdXQgZm9jdXMgcHJvY2Vzc1xuICAgICAganNTZXRGb2N1cyhjb21wb25lbnRFbCwgaW5wdXRFbCwgY29udGVudEVsLCBmb290ZXJFbCwga2V5Ym9hcmRIZWlnaHQpO1xuICAgIH1cbiAgfTtcbiAgY29tcG9uZW50RWwuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2hzdGFydCcsIHRvdWNoU3RhcnQsIHRydWUpO1xuICBjb21wb25lbnRFbC5hZGRFdmVudExpc3RlbmVyKCd0b3VjaGVuZCcsIHRvdWNoRW5kLCB0cnVlKTtcbiAgcmV0dXJuICgpID0+IHtcbiAgICBjb21wb25lbnRFbC5yZW1vdmVFdmVudExpc3RlbmVyKCd0b3VjaHN0YXJ0JywgdG91Y2hTdGFydCwgdHJ1ZSk7XG4gICAgY29tcG9uZW50RWwucmVtb3ZlRXZlbnRMaXN0ZW5lcigndG91Y2hlbmQnLCB0b3VjaEVuZCwgdHJ1ZSk7XG4gIH07XG59O1xuY29uc3QganNTZXRGb2N1cyA9IGFzeW5jIChjb21wb25lbnRFbCwgaW5wdXRFbCwgY29udGVudEVsLCBmb290ZXJFbCwga2V5Ym9hcmRIZWlnaHQpID0+IHtcbiAgaWYgKCFjb250ZW50RWwgJiYgIWZvb3RlckVsKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbnN0IHNjcm9sbERhdGEgPSBnZXRTY3JvbGxEYXRhKGNvbXBvbmVudEVsLCAoY29udGVudEVsIHx8IGZvb3RlckVsKSwga2V5Ym9hcmRIZWlnaHQpO1xuICBpZiAoY29udGVudEVsICYmIE1hdGguYWJzKHNjcm9sbERhdGEuc2Nyb2xsQW1vdW50KSA8IDQpIHtcbiAgICAvLyB0aGUgdGV4dCBpbnB1dCBpcyBpbiBhIHNhZmUgcG9zaXRpb24gdGhhdCBkb2Vzbid0XG4gICAgLy8gcmVxdWlyZSBpdCB0byBiZSBzY3JvbGxlZCBpbnRvIHZpZXcsIGp1c3Qgc2V0IGZvY3VzIG5vd1xuICAgIGlucHV0RWwuZm9jdXMoKTtcbiAgICByZXR1cm47XG4gIH1cbiAgLy8gdGVtcG9yYXJpbHkgbW92ZSB0aGUgZm9jdXMgdG8gdGhlIGZvY3VzIGhvbGRlciBzbyB0aGUgYnJvd3NlclxuICAvLyBkb2Vzbid0IGZyZWFrIG91dCB3aGlsZSBpdCdzIHRyeWluZyB0byBnZXQgdGhlIGlucHV0IGluIHBsYWNlXG4gIC8vIGF0IHRoaXMgcG9pbnQgdGhlIG5hdGl2ZSB0ZXh0IGlucHV0IHN0aWxsIGRvZXMgbm90IGhhdmUgZm9jdXNcbiAgcmVsb2NhdGVJbnB1dChjb21wb25lbnRFbCwgaW5wdXRFbCwgdHJ1ZSwgc2Nyb2xsRGF0YS5pbnB1dFNhZmVZKTtcbiAgaW5wdXRFbC5mb2N1cygpO1xuICAvKipcbiAgICogUmVsb2NhdGluZy9Gb2N1c2luZyBpbnB1dCBjYXVzZXMgdGhlXG4gICAqIGNsaWNrIGV2ZW50IHRvIGJlIGNhbmNlbGxlZCwgc29cbiAgICogbWFudWFsbHkgZmlyZSBvbmUgaGVyZS5cbiAgICovXG4gIHJhZigoKSA9PiBjb21wb25lbnRFbC5jbGljaygpKTtcbiAgLyogdHNsaW50OmRpc2FibGUtbmV4dC1saW5lICovXG4gIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJykge1xuICAgIGxldCBzY3JvbGxDb250ZW50VGltZW91dDtcbiAgICBjb25zdCBzY3JvbGxDb250ZW50ID0gYXN5bmMgKCkgPT4ge1xuICAgICAgLy8gY2xlYW4gdXAgbGlzdGVuZXJzIGFuZCB0aW1lb3V0c1xuICAgICAgaWYgKHNjcm9sbENvbnRlbnRUaW1lb3V0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHNjcm9sbENvbnRlbnRUaW1lb3V0KTtcbiAgICAgIH1cbiAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdpb25LZXlib2FyZERpZFNob3cnLCBkb3VibGVLZXlib2FyZEV2ZW50TGlzdGVuZXIpO1xuICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2lvbktleWJvYXJkRGlkU2hvdycsIHNjcm9sbENvbnRlbnQpO1xuICAgICAgLy8gc2Nyb2xsIHRoZSBpbnB1dCBpbnRvIHBsYWNlXG4gICAgICBpZiAoY29udGVudEVsKSB7XG4gICAgICAgIGF3YWl0IGNvbnRlbnRFbC5zY3JvbGxCeVBvaW50KDAsIHNjcm9sbERhdGEuc2Nyb2xsQW1vdW50LCBzY3JvbGxEYXRhLnNjcm9sbER1cmF0aW9uKTtcbiAgICAgIH1cbiAgICAgIC8vIHRoZSBzY3JvbGwgdmlldyBpcyBpbiB0aGUgY29ycmVjdCBwb3NpdGlvbiBub3dcbiAgICAgIC8vIGdpdmUgdGhlIG5hdGl2ZSB0ZXh0IGlucHV0IGZvY3VzXG4gICAgICByZWxvY2F0ZUlucHV0KGNvbXBvbmVudEVsLCBpbnB1dEVsLCBmYWxzZSwgc2Nyb2xsRGF0YS5pbnB1dFNhZmVZKTtcbiAgICAgIC8vIGVuc3VyZSB0aGlzIGlzIHRoZSBmb2N1c2VkIGlucHV0XG4gICAgICBpbnB1dEVsLmZvY3VzKCk7XG4gICAgfTtcbiAgICBjb25zdCBkb3VibGVLZXlib2FyZEV2ZW50TGlzdGVuZXIgPSAoKSA9PiB7XG4gICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcignaW9uS2V5Ym9hcmREaWRTaG93JywgZG91YmxlS2V5Ym9hcmRFdmVudExpc3RlbmVyKTtcbiAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdpb25LZXlib2FyZERpZFNob3cnLCBzY3JvbGxDb250ZW50KTtcbiAgICB9O1xuICAgIGlmIChjb250ZW50RWwpIHtcbiAgICAgIGNvbnN0IHNjcm9sbEVsID0gYXdhaXQgY29udGVudEVsLmdldFNjcm9sbEVsZW1lbnQoKTtcbiAgICAgIC8qKlxuICAgICAgICogc2Nyb2xsRGF0YSB3aWxsIG9ubHkgY29uc2lkZXIgdGhlIGFtb3VudCB3ZSBuZWVkXG4gICAgICAgKiB0byBzY3JvbGwgaW4gb3JkZXIgdG8gcHJvcGVybHkgYnJpbmcgdGhlIGlucHV0XG4gICAgICAgKiBpbnRvIHZpZXcuIEl0IHdpbGwgbm90IGNvbnNpZGVyIHRoZSBhbW91bnRcbiAgICAgICAqIHdlIGNhbiBzY3JvbGwgaW4gdGhlIGNvbnRlbnQgZWxlbWVudC5cbiAgICAgICAqIEFzIGEgcmVzdWx0LCBzY3JvbGxEYXRhIG1heSByZXF1ZXN0IGEgZ3JlYXRlclxuICAgICAgICogc2Nyb2xsIHBvc2l0aW9uIHRoYW4gaXMgY3VycmVudGx5IGF2YWlsYWJsZVxuICAgICAgICogaW4gdGhlIERPTS4gSWYgdGhpcyBpcyB0aGUgY2FzZSwgd2UgbmVlZCB0b1xuICAgICAgICogd2FpdCBmb3IgdGhlIHdlYnZpZXcgdG8gcmVzaXplL3RoZSBrZXlib2FyZFxuICAgICAgICogdG8gc2hvdyBpbiBvcmRlciBmb3IgYWRkaXRpb25hbCBzY3JvbGxcbiAgICAgICAqIGJhbmR3aWR0aCB0byBiZWNvbWUgYXZhaWxhYmxlLlxuICAgICAgICovXG4gICAgICBjb25zdCB0b3RhbFNjcm9sbEFtb3VudCA9IHNjcm9sbEVsLnNjcm9sbEhlaWdodCAtIHNjcm9sbEVsLmNsaWVudEhlaWdodDtcbiAgICAgIGlmIChzY3JvbGxEYXRhLnNjcm9sbEFtb3VudCA+ICh0b3RhbFNjcm9sbEFtb3VudCAtIHNjcm9sbEVsLnNjcm9sbFRvcCkpIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIE9uIGlPUyBkZXZpY2VzLCB0aGUgc3lzdGVtIHdpbGwgc2hvdyBhIFwiUGFzc3dvcmRzXCIgYmFyIGFib3ZlIHRoZSBrZXlib2FyZFxuICAgICAgICAgKiBhZnRlciB0aGUgaW5pdGlhbCBrZXlib2FyZCBpcyBzaG93bi4gVGhpcyBwcmV2ZW50cyB0aGUgd2VidmlldyBmcm9tIHJlc2l6aW5nXG4gICAgICAgICAqIHVudGlsIHRoZSBcIlBhc3N3b3Jkc1wiIGJhciBpcyBzaG93biwgc28gd2UgbmVlZCB0byB3YWl0IGZvciB0aGF0IHRvIGhhcHBlbiBmaXJzdC5cbiAgICAgICAgICovXG4gICAgICAgIGlmIChpbnB1dEVsLnR5cGUgPT09ICdwYXNzd29yZCcpIHtcbiAgICAgICAgICAvLyBBZGQgNTBweCB0byBhY2NvdW50IGZvciB0aGUgXCJQYXNzd29yZHNcIiBiYXJcbiAgICAgICAgICBzY3JvbGxEYXRhLnNjcm9sbEFtb3VudCArPSA1MDtcbiAgICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignaW9uS2V5Ym9hcmREaWRTaG93JywgZG91YmxlS2V5Ym9hcmRFdmVudExpc3RlbmVyKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignaW9uS2V5Ym9hcmREaWRTaG93Jywgc2Nyb2xsQ29udGVudCk7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoaXMgc2hvdWxkIG9ubHkgZmlyZSBpbiAyIGluc3RhbmNlczpcbiAgICAgICAgICogMS4gVGhlIGFwcCBpcyB2ZXJ5IHNsb3cuXG4gICAgICAgICAqIDIuIFRoZSBhcHAgaXMgcnVubmluZyBpbiBhIGJyb3dzZXIgb24gYW4gb2xkIE9TXG4gICAgICAgICAqIHRoYXQgZG9lcyBub3Qgc3VwcG9ydCBJb25pYyBLZXlib2FyZCBFdmVudHNcbiAgICAgICAgICovXG4gICAgICAgIHNjcm9sbENvbnRlbnRUaW1lb3V0ID0gc2V0VGltZW91dChzY3JvbGxDb250ZW50LCAxMDAwKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH1cbiAgICBzY3JvbGxDb250ZW50KCk7XG4gIH1cbn07XG5jb25zdCBoYXNQb2ludGVyTW92ZWQgPSAodGhyZXNob2xkLCBzdGFydENvb3JkLCBlbmRDb29yZCkgPT4ge1xuICBpZiAoc3RhcnRDb29yZCAmJiBlbmRDb29yZCkge1xuICAgIGNvbnN0IGRlbHRhWCA9IChzdGFydENvb3JkLnggLSBlbmRDb29yZC54KTtcbiAgICBjb25zdCBkZWx0YVkgPSAoc3RhcnRDb29yZC55IC0gZW5kQ29vcmQueSk7XG4gICAgY29uc3QgZGlzdGFuY2UgPSBkZWx0YVggKiBkZWx0YVggKyBkZWx0YVkgKiBkZWx0YVk7XG4gICAgcmV0dXJuIGRpc3RhbmNlID4gKHRocmVzaG9sZCAqIHRocmVzaG9sZCk7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufTtcblxuY29uc3QgUEFERElOR19USU1FUl9LRVkgPSAnJGlvblBhZGRpbmdUaW1lcic7XG5jb25zdCBlbmFibGVTY3JvbGxQYWRkaW5nID0gKGtleWJvYXJkSGVpZ2h0KSA9PiB7XG4gIGNvbnN0IGRvYyA9IGRvY3VtZW50O1xuICBjb25zdCBvbkZvY3VzaW4gPSAoZXYpID0+IHtcbiAgICBzZXRTY3JvbGxQYWRkaW5nKGV2LnRhcmdldCwga2V5Ym9hcmRIZWlnaHQpO1xuICB9O1xuICBjb25zdCBvbkZvY3Vzb3V0ID0gKGV2KSA9PiB7XG4gICAgc2V0U2Nyb2xsUGFkZGluZyhldi50YXJnZXQsIDApO1xuICB9O1xuICBkb2MuYWRkRXZlbnRMaXN0ZW5lcignZm9jdXNpbicsIG9uRm9jdXNpbik7XG4gIGRvYy5hZGRFdmVudExpc3RlbmVyKCdmb2N1c291dCcsIG9uRm9jdXNvdXQpO1xuICByZXR1cm4gKCkgPT4ge1xuICAgIGRvYy5yZW1vdmVFdmVudExpc3RlbmVyKCdmb2N1c2luJywgb25Gb2N1c2luKTtcbiAgICBkb2MucmVtb3ZlRXZlbnRMaXN0ZW5lcignZm9jdXNvdXQnLCBvbkZvY3Vzb3V0KTtcbiAgfTtcbn07XG5jb25zdCBzZXRTY3JvbGxQYWRkaW5nID0gKGlucHV0LCBrZXlib2FyZEhlaWdodCkgPT4ge1xuICBpZiAoaW5wdXQudGFnTmFtZSAhPT0gJ0lOUFVUJykge1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAoaW5wdXQucGFyZW50RWxlbWVudCAmJiBpbnB1dC5wYXJlbnRFbGVtZW50LnRhZ05hbWUgPT09ICdJT04tSU5QVVQnKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGlmIChpbnB1dC5wYXJlbnRFbGVtZW50ICYmXG4gICAgaW5wdXQucGFyZW50RWxlbWVudC5wYXJlbnRFbGVtZW50ICYmXG4gICAgaW5wdXQucGFyZW50RWxlbWVudC5wYXJlbnRFbGVtZW50LnRhZ05hbWUgPT09ICdJT04tU0VBUkNIQkFSJykge1xuICAgIHJldHVybjtcbiAgfVxuICBjb25zdCBlbCA9IGlucHV0LmNsb3Nlc3QoJ2lvbi1jb250ZW50Jyk7XG4gIGlmIChlbCA9PT0gbnVsbCkge1xuICAgIHJldHVybjtcbiAgfVxuICBjb25zdCB0aW1lciA9IGVsW1BBRERJTkdfVElNRVJfS0VZXTtcbiAgaWYgKHRpbWVyKSB7XG4gICAgY2xlYXJUaW1lb3V0KHRpbWVyKTtcbiAgfVxuICBpZiAoa2V5Ym9hcmRIZWlnaHQgPiAwKSB7XG4gICAgZWwuc3R5bGUuc2V0UHJvcGVydHkoJy0ta2V5Ym9hcmQtb2Zmc2V0JywgYCR7a2V5Ym9hcmRIZWlnaHR9cHhgKTtcbiAgfVxuICBlbHNlIHtcbiAgICBlbFtQQURESU5HX1RJTUVSX0tFWV0gPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIGVsLnN0eWxlLnNldFByb3BlcnR5KCctLWtleWJvYXJkLW9mZnNldCcsICcwcHgnKTtcbiAgICB9LCAxMjApO1xuICB9XG59O1xuXG5jb25zdCBJTlBVVF9CTFVSUklORyA9IHRydWU7XG5jb25zdCBTQ1JPTExfUEFERElORyA9IHRydWU7XG5jb25zdCBzdGFydElucHV0U2hpbXMgPSAoY29uZmlnKSA9PiB7XG4gIGNvbnN0IGRvYyA9IGRvY3VtZW50O1xuICBjb25zdCBrZXlib2FyZEhlaWdodCA9IGNvbmZpZy5nZXROdW1iZXIoJ2tleWJvYXJkSGVpZ2h0JywgMjkwKTtcbiAgY29uc3Qgc2Nyb2xsQXNzaXN0ID0gY29uZmlnLmdldEJvb2xlYW4oJ3Njcm9sbEFzc2lzdCcsIHRydWUpO1xuICBjb25zdCBoaWRlQ2FyZXQgPSBjb25maWcuZ2V0Qm9vbGVhbignaGlkZUNhcmV0T25TY3JvbGwnLCB0cnVlKTtcbiAgY29uc3QgaW5wdXRCbHVycmluZyA9IGNvbmZpZy5nZXRCb29sZWFuKCdpbnB1dEJsdXJyaW5nJywgdHJ1ZSk7XG4gIGNvbnN0IHNjcm9sbFBhZGRpbmcgPSBjb25maWcuZ2V0Qm9vbGVhbignc2Nyb2xsUGFkZGluZycsIHRydWUpO1xuICBjb25zdCBpbnB1dHMgPSBBcnJheS5mcm9tKGRvYy5xdWVyeVNlbGVjdG9yQWxsKCdpb24taW5wdXQsIGlvbi10ZXh0YXJlYScpKTtcbiAgY29uc3QgaGlkZUNhcmV0TWFwID0gbmV3IFdlYWtNYXAoKTtcbiAgY29uc3Qgc2Nyb2xsQXNzaXN0TWFwID0gbmV3IFdlYWtNYXAoKTtcbiAgY29uc3QgcmVnaXN0ZXJJbnB1dCA9IGFzeW5jIChjb21wb25lbnRFbCkgPT4ge1xuICAgIGF3YWl0IG5ldyBQcm9taXNlKHJlc29sdmUgPT4gY29tcG9uZW50T25SZWFkeShjb21wb25lbnRFbCwgcmVzb2x2ZSkpO1xuICAgIGNvbnN0IGlucHV0Um9vdCA9IGNvbXBvbmVudEVsLnNoYWRvd1Jvb3QgfHwgY29tcG9uZW50RWw7XG4gICAgY29uc3QgaW5wdXRFbCA9IGlucHV0Um9vdC5xdWVyeVNlbGVjdG9yKCdpbnB1dCcpIHx8IGlucHV0Um9vdC5xdWVyeVNlbGVjdG9yKCd0ZXh0YXJlYScpO1xuICAgIGNvbnN0IHNjcm9sbEVsID0gY29tcG9uZW50RWwuY2xvc2VzdCgnaW9uLWNvbnRlbnQnKTtcbiAgICBjb25zdCBmb290ZXJFbCA9ICghc2Nyb2xsRWwpID8gY29tcG9uZW50RWwuY2xvc2VzdCgnaW9uLWZvb3RlcicpIDogbnVsbDtcbiAgICBpZiAoIWlucHV0RWwpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKCEhc2Nyb2xsRWwgJiYgaGlkZUNhcmV0ICYmICFoaWRlQ2FyZXRNYXAuaGFzKGNvbXBvbmVudEVsKSkge1xuICAgICAgY29uc3Qgcm1GbiA9IGVuYWJsZUhpZGVDYXJldE9uU2Nyb2xsKGNvbXBvbmVudEVsLCBpbnB1dEVsLCBzY3JvbGxFbCk7XG4gICAgICBoaWRlQ2FyZXRNYXAuc2V0KGNvbXBvbmVudEVsLCBybUZuKTtcbiAgICB9XG4gICAgaWYgKCghIXNjcm9sbEVsIHx8ICEhZm9vdGVyRWwpICYmIHNjcm9sbEFzc2lzdCAmJiAhc2Nyb2xsQXNzaXN0TWFwLmhhcyhjb21wb25lbnRFbCkpIHtcbiAgICAgIGNvbnN0IHJtRm4gPSBlbmFibGVTY3JvbGxBc3Npc3QoY29tcG9uZW50RWwsIGlucHV0RWwsIHNjcm9sbEVsLCBmb290ZXJFbCwga2V5Ym9hcmRIZWlnaHQpO1xuICAgICAgc2Nyb2xsQXNzaXN0TWFwLnNldChjb21wb25lbnRFbCwgcm1Gbik7XG4gICAgfVxuICB9O1xuICBjb25zdCB1bnJlZ2lzdGVySW5wdXQgPSAoY29tcG9uZW50RWwpID0+IHtcbiAgICBpZiAoaGlkZUNhcmV0KSB7XG4gICAgICBjb25zdCBmbiA9IGhpZGVDYXJldE1hcC5nZXQoY29tcG9uZW50RWwpO1xuICAgICAgaWYgKGZuKSB7XG4gICAgICAgIGZuKCk7XG4gICAgICB9XG4gICAgICBoaWRlQ2FyZXRNYXAuZGVsZXRlKGNvbXBvbmVudEVsKTtcbiAgICB9XG4gICAgaWYgKHNjcm9sbEFzc2lzdCkge1xuICAgICAgY29uc3QgZm4gPSBzY3JvbGxBc3Npc3RNYXAuZ2V0KGNvbXBvbmVudEVsKTtcbiAgICAgIGlmIChmbikge1xuICAgICAgICBmbigpO1xuICAgICAgfVxuICAgICAgc2Nyb2xsQXNzaXN0TWFwLmRlbGV0ZShjb21wb25lbnRFbCk7XG4gICAgfVxuICB9O1xuICBpZiAoaW5wdXRCbHVycmluZyAmJiBJTlBVVF9CTFVSUklORykge1xuICAgIGVuYWJsZUlucHV0Qmx1cnJpbmcoKTtcbiAgfVxuICBpZiAoc2Nyb2xsUGFkZGluZyAmJiBTQ1JPTExfUEFERElORykge1xuICAgIGVuYWJsZVNjcm9sbFBhZGRpbmcoa2V5Ym9hcmRIZWlnaHQpO1xuICB9XG4gIC8vIElucHV0IG1pZ2h0IGJlIGFscmVhZHkgbG9hZGVkIGluIHRoZSBET00gYmVmb3JlIGlvbi1kZXZpY2UtaGFja3MgZGlkLlxuICAvLyBBdCB0aGlzIHBvaW50IHdlIG5lZWQgdG8gbG9vayBmb3IgYWxsIG9mIHRoZSBpbnB1dHMgbm90IHJlZ2lzdGVyZWQgeWV0XG4gIC8vIGFuZCByZWdpc3RlciB0aGVtLlxuICBmb3IgKGNvbnN0IGlucHV0IG9mIGlucHV0cykge1xuICAgIHJlZ2lzdGVySW5wdXQoaW5wdXQpO1xuICB9XG4gIGRvYy5hZGRFdmVudExpc3RlbmVyKCdpb25JbnB1dERpZExvYWQnLCAoKGV2KSA9PiB7XG4gICAgcmVnaXN0ZXJJbnB1dChldi5kZXRhaWwpO1xuICB9KSk7XG4gIGRvYy5hZGRFdmVudExpc3RlbmVyKCdpb25JbnB1dERpZFVubG9hZCcsICgoZXYpID0+IHtcbiAgICB1bnJlZ2lzdGVySW5wdXQoZXYuZGV0YWlsKTtcbiAgfSkpO1xufTtcblxuZXhwb3J0IHsgc3RhcnRJbnB1dFNoaW1zIH07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../ishlibjs/node_modules/@ionic/core/components/input-shims.js\n");

/***/ })

};
;